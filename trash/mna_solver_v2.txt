
#ifndef MNA_SOLVER_V2_H
#define MNA_SOLVER_V2_H

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <complex.h>
#include <stdalign.h>
#include <string.h>
#include <stdbool.h>

// Error codes
typedef enum {
    MNA_SUCCESS,
    MNA_COMPONENT_LIMIT_REACHED,   // Kept for API compatibility; not used in v2
    MNA_MATRIX_SINGULAR,
    MNA_CONVERGENCE_FAILURE,
    MNA_INVALID_HANDLE,
    MNA_INVALID_NODE,
    MNA_INSUFFICIENT_MEMORY,
    MNA_INVALID_PARAMETER
} MNAStatus;

// Opaque component handle
typedef int ComponentHandle;

// Default initial capacities (grow automatically)
#define MNA_INIT_NODES_CAP     16
#define MNA_INIT_SOURCES_CAP   8
#define MNA_INIT_COMPONENTS_CAP 64

#define MNA_MAX_NONLINEAR 20
#define MNA_MAX_ITER 50
#define MNA_RELTOL 1e-6
#define MNA_ABSTOL 1e-9
#define MNA_VT 0.02585
#define MNA_MIN_CONDUCTANCE 1e-12
#define MNA_MAX_CONDUCTANCE 1e12
#define TWO_PI 6.28318530717958647692

// Unified nonlinear element type
typedef enum {
    NONLINEAR_RESISTOR,
    NONLINEAR_CAPACITOR,
    NONLINEAR_INDUCTOR
} NonlinearType;

// Unified source type
typedef enum {
    SOURCE_VOLTAGE,
    SOURCE_CURRENT
} SourceType;

typedef enum {
    MNA_RESISTOR,
    MNA_CAPACITOR,
    MNA_INDUCTOR,
    MNA_SOURCE,
    MNA_SWITCH,
    MNA_CUSTOM_NONLINEAR
} ComponentType;

// Component state for nonlinear callbacks
typedef struct {
    double voltage;
    double current;
    double charge;
    double flux;
    double dt;
} ComponentState;

// Generalized nonlinear function interface
typedef void (*CustomNonlinearFunc)(const ComponentState* state, void* user_data,
                                  double* value1, double* value2);

typedef struct {
    ComponentType type;
    int node1;
    int node2;
    double value;        // DC value
    double ac_magnitude;
    double ac_phase;
    int state;
    bool is_nonlinear;

    // Source-specific fields
    SourceType source_type;

    // Nonlinear-specific fields
    NonlinearType nonlinear_type;
    double last_voltage;
    double last_current;
    double last_conductance;
    double last_charge;
    double last_flux;
    CustomNonlinearFunc nonlinear_func;
    void* user_data;

    // Transient companion model
    double trans_G_eq;
    double trans_I_eq;
} Component;

typedef struct MNASolver {
    // "Active" counts
    int num_nodes;          // number of created nodes (excludes ground 0)
    int num_components;
    int num_sources;        // number of independent voltage sources
    int num_nonlinear;
    int max_node_index;     // highest node index allocated
    int transient_initialized; // 0 or 1
    double time;
    double dt;

    // Dynamic arrays
    Component* components;
    double* A;              // real system matrix (capacity size)
    double* b;              // RHS (capacity size)
    double* x;              // solution (capacity size)
    double complex* ac_solution; // AC solution (capacity size)

    // Capacity tracking
    int cap_nodes;          // capacity in nodes (excludes ground)
    int cap_sources;        // capacity in indep voltage sources
    int cap_components;
    int matrix_cap_size;    // cap_nodes + cap_sources

} MNASolver;

// mna_destroy declaration.
void mna_destroy(MNASolver* solver);

// Matrix access macro (capacity-indexed). Use active ranges when filling.
#define MAT(solver, i, j) ((solver)->A[(i) * (solver)->matrix_cap_size + (j)])

// ---- Internal helpers ----------------------------------------------------

static inline int mna_active_size(const MNASolver* s) {
    return s->max_node_index + s->num_sources;
}

static bool mna_resize_components(MNASolver* s, int required) {
    if (required <= s->cap_components) return true;
    int new_cap = s->cap_components ? s->cap_components : MNA_INIT_COMPONENTS_CAP;
    while (new_cap < required) new_cap = (int)(new_cap * 1.5) + 1;
    Component* nxt = (Component*)realloc(s->components, (size_t)new_cap * sizeof(Component));
    if (!nxt) return false;
    // Zero-initialize the new tail
    if (new_cap > s->cap_components) {
        size_t added = (size_t)(new_cap - s->cap_components);
        memset(nxt + s->cap_components, 0, added * sizeof(Component));
    }
    s->components = nxt;
    s->cap_components = new_cap;
    return true;
}

static bool mna_resize_matrix(MNASolver* s, int req_nodes, int req_sources) {
    int need_nodes = (req_nodes > s->cap_nodes) ? req_nodes : s->cap_nodes;
    int need_sources = (req_sources > s->cap_sources) ? req_sources : s->cap_sources;
    int need_size = need_nodes + need_sources;
    if (need_size <= s->matrix_cap_size) {
        // No matrix growth needed, but maybe node/source caps need bump without matrix increase
        s->cap_nodes = need_nodes;
        s->cap_sources = need_sources;
        return true;
    }

    // Grow nodes/sources geometrically
    int new_nodes_cap = s->cap_nodes ? s->cap_nodes : MNA_INIT_NODES_CAP;
    int new_sources_cap = s->cap_sources ? s->cap_sources : MNA_INIT_SOURCES_CAP;
    while (new_nodes_cap < req_nodes)   new_nodes_cap = (int)(new_nodes_cap * 1.5) + 1;
    while (new_sources_cap < req_sources) new_sources_cap = (int)(new_sources_cap * 1.5) + 1;

    int new_size = new_nodes_cap + new_sources_cap;
    size_t elems = (size_t)new_size * (size_t)new_size;

    double* A2 = (double*)calloc(elems, sizeof(double));
    double* b2 = (double*)calloc((size_t)new_size, sizeof(double));
    double* x2 = (double*)calloc((size_t)new_size, sizeof(double));
    double complex* ac2 = (double complex*)calloc((size_t)new_size, sizeof(double complex));
    if (!A2 || !b2 || !x2 || !ac2) {
        free(A2); free(b2); free(x2); free(ac2);
        return false;
    }

    // Copy old active region into new buffers
    int old_size = s->matrix_cap_size;
    if (s->A && old_size > 0) {
        for (int i = 0; i < old_size; ++i) {
            memcpy(A2 + (size_t)i * new_size, s->A + (size_t)i * old_size, (size_t)old_size * sizeof(double));
        }
        memcpy(b2, s->b, (size_t)old_size * sizeof(double));
        memcpy(x2, s->x, (size_t)old_size * sizeof(double));
        memcpy(ac2, s->ac_solution, (size_t)old_size * sizeof(double complex));
    }

    free(s->A); free(s->b); free(s->x); free(s->ac_solution);
    s->A = A2; s->b = b2; s->x = x2; s->ac_solution = ac2;
    s->cap_nodes = new_nodes_cap;
    s->cap_sources = new_sources_cap;
    s->matrix_cap_size = new_size;
    return true;
}

static inline bool mna_ensure_component_capacity(MNASolver* s, int want_components) {
    return mna_resize_components(s, want_components);
}

static inline bool mna_ensure_matrix_capacity(MNASolver* s, int want_nodes, int want_sources) {
    // Ensure we can index up to want_nodes/want_sources in the matrix
    return mna_resize_matrix(s, want_nodes, want_sources);
}

// ---- Public API ----------------------------------------------------------

MNAStatus mna_init_sized(MNASolver* solver, int max_nodes, int max_sources, int max_components) {
    memset(solver, 0, sizeof(MNASolver));

    // Set initial capacities (these will grow automatically later)
    solver->cap_nodes = (max_nodes > 0) ? max_nodes : MNA_INIT_NODES_CAP;
    solver->cap_sources = (max_sources > 0) ? max_sources : MNA_INIT_SOURCES_CAP;
    solver->cap_components = (max_components > 0) ? max_components : MNA_INIT_COMPONENTS_CAP;
    solver->matrix_cap_size = solver->cap_nodes + solver->cap_sources;

    // Allocate arrays
    solver->components = (Component*)calloc((size_t)solver->cap_components, sizeof(Component));
    solver->A = (double*)calloc((size_t)solver->matrix_cap_size * (size_t)solver->matrix_cap_size, sizeof(double));
    solver->b = (double*)calloc((size_t)solver->matrix_cap_size, sizeof(double));
    solver->x = (double*)calloc((size_t)solver->matrix_cap_size, sizeof(double));
    solver->ac_solution = (double complex*)calloc((size_t)solver->matrix_cap_size, sizeof(double complex));

    if (!solver->components || !solver->A || !solver->b || !solver->x || !solver->ac_solution) {
        mna_destroy(solver);
        return MNA_INSUFFICIENT_MEMORY;
    }
    return MNA_SUCCESS;
}

void mna_destroy(MNASolver* solver) {
    if (!solver) return;
    free(solver->components);
    free(solver->A);
    free(solver->b);
    free(solver->x);
    free(solver->ac_solution);
    memset(solver, 0, sizeof(MNASolver));
}

MNAStatus mna_init(MNASolver* solver) {
    return mna_init_sized(solver, MNA_INIT_NODES_CAP, MNA_INIT_SOURCES_CAP, MNA_INIT_COMPONENTS_CAP);
}

int mna_create_node(MNASolver* solver) {
    int new_index = solver->max_node_index + 1;
    // Grow capacity if needed
    if (!mna_ensure_matrix_capacity(solver, new_index, solver->num_sources)) {
        return -1; // memory failure
    }
    solver->max_node_index = new_index;
    solver->num_nodes = (solver->num_nodes < new_index) ? new_index : solver->num_nodes;
    return new_index;
}

MNAStatus mna_validate_nodes(MNASolver* solver, int node1, int node2) {
    if (node1 < 0 || node1 > solver->max_node_index ||
        node2 < 0 || node2 > solver->max_node_index) {
        return MNA_INVALID_NODE;
    }
    return MNA_SUCCESS;
}

MNAStatus mna_add_component(MNASolver* solver, ComponentType type, int node1, int node2,
                          double value, SourceType src_type, ComponentHandle* handle) {
    MNAStatus status = mna_validate_nodes(solver, node1, node2);
    if (status != MNA_SUCCESS) return status;

    int new_count = solver->num_components + 1;
    if (!mna_ensure_component_capacity(solver, new_count)) {
        return MNA_INSUFFICIENT_MEMORY;
    }

    Component comp;
    memset(&comp, 0, sizeof(comp));
    comp.type = type;
    comp.node1 = node1;
    comp.node2 = node2;
    comp.value = value;
    comp.state = 1;
    comp.is_nonlinear = false;
    comp.source_type = src_type;
    comp.nonlinear_type = NONLINEAR_RESISTOR;

    int index = solver->num_components++;
    solver->components[index] = comp;

    if (type == MNA_SOURCE && src_type == SOURCE_VOLTAGE) {
        // Ensure matrix capacity for another voltage source column/row
        if (!mna_ensure_matrix_capacity(solver, solver->max_node_index, solver->num_sources + 1)) {
            return MNA_INSUFFICIENT_MEMORY;
        }
        solver->num_sources++;
    }

    if (handle) *handle = index;
    return MNA_SUCCESS;
}

MNAStatus mna_add_resistor(MNASolver* solver, int node1, int node2, double value,
                         ComponentHandle* handle) {
    return mna_add_component(solver, MNA_RESISTOR, node1, node2, value,
                            SOURCE_CURRENT, handle);
}

MNAStatus mna_add_capacitor(MNASolver* solver, int node1, int node2, double value,
                          ComponentHandle* handle) {
    return mna_add_component(solver, MNA_CAPACITOR, node1, node2, value,
                            SOURCE_CURRENT, handle);
}

MNAStatus mna_add_inductor(MNASolver* solver, int node1, int node2, double value,
                         ComponentHandle* handle) {
    return mna_add_component(solver, MNA_INDUCTOR, node1, node2, value,
                            SOURCE_CURRENT, handle);
}

MNAStatus mna_add_voltage_source(MNASolver* solver, int node1, int node2, double value,
                               ComponentHandle* handle) {
    return mna_add_component(solver, MNA_SOURCE, node1, node2, value,
                            SOURCE_VOLTAGE, handle);
}

MNAStatus mna_add_current_source(MNASolver* solver, int node1, int node2, double value,
                               ComponentHandle* handle) {
    return mna_add_component(solver, MNA_SOURCE, node1, node2, value,
                            SOURCE_CURRENT, handle);
}

MNAStatus mna_add_switch(MNASolver* solver, int node1, int node2, double value,
                       ComponentHandle* handle) {
    return mna_add_component(solver, MNA_SWITCH, node1, node2, value,
                            SOURCE_CURRENT, handle);
}

MNAStatus mna_add_custom_nonlinear(MNASolver* solver, int node1, int node2,
                                 NonlinearType nl_type,
                                 CustomNonlinearFunc func, void* user_data,
                                 double initial_value1, double initial_value2,
                                 ComponentHandle* handle) {
    MNAStatus status = mna_validate_nodes(solver, node1, node2);
    if (status != MNA_SUCCESS) return status;

    int new_count = solver->num_components + 1;
    if (!mna_ensure_component_capacity(solver, new_count)) {
        return MNA_INSUFFICIENT_MEMORY;
    }

    Component comp;
    memset(&comp, 0, sizeof(comp));
    comp.type = MNA_CUSTOM_NONLINEAR;
    comp.node1 = node1;
    comp.node2 = node2;
    comp.state = 1;
    comp.is_nonlinear = true;
    comp.source_type = SOURCE_CURRENT;
    comp.nonlinear_type = nl_type;
    comp.nonlinear_func = func;
    comp.user_data = user_data;

    switch (nl_type) {
        case NONLINEAR_RESISTOR:
            comp.last_voltage = initial_value1;
            break;
        case NONLINEAR_CAPACITOR:
            comp.last_voltage = initial_value1;
            comp.last_charge = initial_value2;
            break;
        case NONLINEAR_INDUCTOR:
            comp.last_current = initial_value1;
            comp.last_flux = initial_value2;
            break;
    }

    int index = solver->num_components++;
    solver->components[index] = comp;
    solver->num_nonlinear++;
    if (handle) *handle = index;
    return MNA_SUCCESS;
}

MNAStatus mna_set_ac_source(MNASolver* solver, ComponentHandle handle,
                          double magnitude, double phase) {
    if (handle < 0 || handle >= solver->num_components) {
        return MNA_INVALID_HANDLE;
    }
    solver->components[handle].ac_magnitude = magnitude;
    solver->components[handle].ac_phase = phase;
    return MNA_SUCCESS;
}

MNAStatus mna_set_switch_state(MNASolver* solver, ComponentHandle handle, int state) {
    if (handle < 0 || handle >= solver->num_components) {
        return MNA_INVALID_HANDLE;
    }
    Component* comp = &solver->components[handle];
    if (comp->type == MNA_SWITCH) {
        comp->state = state;
        return MNA_SUCCESS;
    }
    return MNA_INVALID_HANDLE;
}

void mna_reset_system(MNASolver* solver) {
    int active = mna_active_size(solver);
    // Zero only the active, upper-left submatrix to reduce work
    for (int i = 0; i < active; ++i) {
        memset(&MAT(solver, i, 0), 0, (size_t)active * sizeof(double));
    }
    memset(solver->b, 0, (size_t)active * sizeof(double));
    memset(solver->x, 0, (size_t)active * sizeof(double));
}

void mna_stamp_conductance(MNASolver* solver, int node1, int node2, double g) {
    if (node1 > 0) MAT(solver, node1-1, node1-1) += g;
    if (node2 > 0) MAT(solver, node2-1, node2-1) += g;
    if (node1 > 0 && node2 > 0) {
        MAT(solver, node1-1, node2-1) -= g;
        MAT(solver, node2-1, node1-1) -= g;
    }
}

void mna_stamp_current_source(MNASolver* solver, int node1, int node2, double current_val) {
    if (node1 > 0) solver->b[node1-1] -= current_val;
    if (node2 > 0) solver->b[node2-1] += current_val;
}

void mna_stamp_voltage_source(MNASolver* solver, int comp_index, int source_idx) {
    Component* vs = &solver->components[comp_index];
    int v_index = solver->max_node_index + source_idx;
    int n1 = vs->node1;
    int n2 = vs->node2;

    if (n1 > 0) {
        MAT(solver, n1-1, v_index) = 1.0;
        MAT(solver, v_index, n1-1) = 1.0;
    }
    if (n2 > 0) {
        MAT(solver, n2-1, v_index) = -1.0;
        MAT(solver, v_index, n2-1) = -1.0;
    }

    solver->b[v_index] = vs->value;
}

void mna_stamp_custom_nonlinear(MNASolver* solver, int comp_index, int is_dc) {
    Component* comp = &solver->components[comp_index];
    int n1 = comp->node1;
    int n2 = comp->node2;

    ComponentState state = {
        .voltage = comp->last_voltage,
        .current = comp->last_current,
        .charge = comp->last_charge,
        .flux = comp->last_flux,
        .dt = solver->dt
    };

    switch (comp->nonlinear_type) {
        case NONLINEAR_RESISTOR: {
            double current, conductance;
            comp->nonlinear_func(&state, comp->user_data, &current, &conductance);

            if (conductance < MNA_MIN_CONDUCTANCE) conductance = MNA_MIN_CONDUCTANCE;
            if (conductance > MNA_MAX_CONDUCTANCE) conductance = MNA_MAX_CONDUCTANCE;

            mna_stamp_conductance(solver, n1, n2, conductance);
            mna_stamp_current_source(solver, n1, n2, (current - conductance * state.voltage));
            break;
        }

        case NONLINEAR_CAPACITOR: {
            if (is_dc) {
                mna_stamp_conductance(solver, n1, n2, MNA_MIN_CONDUCTANCE);
            } else {
                double q0, C0;
                comp->nonlinear_func(&state, comp->user_data, &q0, &C0);

                double G_eq = C0 / solver->dt;
                double I_eq = (q0 - comp->last_charge) / solver->dt - G_eq * state.voltage;

                comp->trans_G_eq = G_eq;
                comp->trans_I_eq = I_eq;

                mna_stamp_conductance(solver, n1, n2, G_eq);
                mna_stamp_current_source(solver, n1, n2, I_eq);
            }
            break;
        }

        case NONLINEAR_INDUCTOR: {
            if (is_dc) {
                mna_stamp_conductance(solver, n1, n2, MNA_MAX_CONDUCTANCE);
            } else {
                double phi0, L0;
                comp->nonlinear_func(&state, comp->user_data, &phi0, &L0);

                double G_eq = solver->dt / L0;
                double I_eq = state.current + (phi0 - comp->last_flux) / L0;

                comp->trans_G_eq = G_eq;
                comp->trans_I_eq = I_eq;

                mna_stamp_conductance(solver, n1, n2, G_eq);
                mna_stamp_current_source(solver, n1, n2, I_eq);
            }
            break;
        }
    }
}

MNAStatus mna_solve_linear_system(MNASolver* solver, int size) {
    const double pivot_threshold = 1e-12;
    double max_val;
    int max_row;

    for (int pivot = 0; pivot < size; pivot++) {
        // Find pivot (partial pivoting)
        max_row = pivot;
        max_val = fabs(MAT(solver, pivot, pivot));
        for (int i = pivot + 1; i < size; i++) {
            double abs_val = fabs(MAT(solver, i, pivot));
            if (abs_val > max_val) {
                max_val = abs_val;
                max_row = i;
            }
        }

        // Singularity check
        if (max_val < pivot_threshold) {
            return MNA_MATRIX_SINGULAR;
        }

        // Swap rows if needed
        if (max_row != pivot) {
            for (int j = pivot; j < size; j++) {
                double temp = MAT(solver, pivot, j);
                MAT(solver, pivot, j) = MAT(solver, max_row, j);
                MAT(solver, max_row, j) = temp;
            }
            double tempb = solver->b[pivot];
            solver->b[pivot] = solver->b[max_row];
            solver->b[max_row] = tempb;
        }

        // Elimination
        const double pivot_inv = 1.0 / MAT(solver, pivot, pivot);
        for (int i = pivot + 1; i < size; i++) {
            double factor = MAT(solver, i, pivot) * pivot_inv;
            if (factor == 0.0) continue;
            for (int j = pivot + 1; j < size; j++) {
                MAT(solver, i, j) -= factor * MAT(solver, pivot, j);
            }
            solver->b[i] -= factor * solver->b[pivot];
            MAT(solver, i, pivot) = 0.0;
        }
    }

    // Back substitution
    for (int i = size - 1; i >= 0; i--) {
        double sum = solver->b[i];
        for (int j = i + 1; j < size; j++) {
            sum -= MAT(solver, i, j) * solver->x[j];
        }
        solver->x[i] = sum / MAT(solver, i, i);
    }

    return MNA_SUCCESS;
}

MNAStatus mna_solve_dc(MNASolver* solver) {
    const int matrix_size = mna_active_size(solver);
    const bool has_nonlinear = (solver->num_nonlinear > 0);

    if (!has_nonlinear) {
        // Standard linear solution for circuits without nonlinear components
        mna_reset_system(solver);
        int source_count = 0;

        for (int i = 0; i < solver->num_components; i++) {
            Component* comp = &solver->components[i];
            const int n1 = comp->node1;
            const int n2 = comp->node2;

            switch (comp->type) {
                case MNA_RESISTOR:
                    mna_stamp_conductance(solver, n1, n2, 1.0 / comp->value);
                    break;
                case MNA_CAPACITOR:
                    mna_stamp_conductance(solver, n1, n2, MNA_MIN_CONDUCTANCE);
                    break;
                case MNA_INDUCTOR:
                    mna_stamp_conductance(solver, n1, n2, MNA_MAX_CONDUCTANCE);
                    break;
                case MNA_SOURCE:
                    if (comp->source_type == SOURCE_VOLTAGE) {
                        mna_stamp_voltage_source(solver, i, source_count++);
                    } else {
                        mna_stamp_current_source(solver, n1, n2, comp->value);
                    }
                    break;
                case MNA_CUSTOM_NONLINEAR:
                    // Fallback
                    mna_stamp_conductance(solver, n1, n2, MNA_MIN_CONDUCTANCE);
                    break;
                case MNA_SWITCH: {
                    const double g = comp->state ?
                        1.0 / comp->value : MNA_MIN_CONDUCTANCE;
                    mna_stamp_conductance(solver, n1, n2, g);
                    break;
                }
            }
        }
        return mna_solve_linear_system(solver, matrix_size);
    }

    // Nonlinear circuit - source stepping with adaptive step size
    double* orig_source_values = (double*)malloc((size_t)solver->num_components * sizeof(double));
    if (!orig_source_values) return MNA_INSUFFICIENT_MEMORY;

    // Save original source values and set initial state to zero
    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        if (comp->type == MNA_SOURCE) {
            orig_source_values[i] = comp->value;
            comp->value = 0.0;  // Start from zero
        }
        if (comp->type == MNA_CUSTOM_NONLINEAR) {
            comp->last_voltage = 0.0;  // Reset to known state
            comp->last_conductance = MNA_MIN_CONDUCTANCE;
        }
    }

    // Source stepping parameters
    double current_factor = 0.0;
    const double min_step = 0.01;  // Minimum step size (1%)
    const double max_step = 0.2;   // Maximum step size (20%)
    double step_size = max_step;
    MNAStatus status = MNA_SUCCESS;
    int total_steps = 0;
    const int max_total_steps = 200;

    while (current_factor < 1.0 && total_steps < max_total_steps) {
        double next_factor = current_factor + step_size;
        if (next_factor > 1.0) next_factor = 1.0;

        // Update sources to current factor
        for (int i = 0; i < solver->num_components; i++) {
            Component* comp = &solver->components[i];
            if (comp->type == MNA_SOURCE) {
                comp->value = orig_source_values[i] * next_factor;
            }
        }

        // Solve at current source level
        mna_reset_system(solver);
        int source_count = 0;

        for (int i = 0; i < solver->num_components; i++) {
            Component* comp = &solver->components[i];
            const int n1 = comp->node1;
            const int n2 = comp->node2;

            switch (comp->type) {
                case MNA_RESISTOR:
                    mna_stamp_conductance(solver, n1, n2, 1.0 / comp->value);
                    break;
                case MNA_CAPACITOR:
                    mna_stamp_conductance(solver, n1, n2, MNA_MIN_CONDUCTANCE);
                    break;
                case MNA_INDUCTOR:
                    mna_stamp_conductance(solver, n1, n2, MNA_MAX_CONDUCTANCE);
                    break;
                case MNA_SOURCE:
                    if (comp->source_type == SOURCE_VOLTAGE) {
                        mna_stamp_voltage_source(solver, i, source_count++);
                    } else {
                        mna_stamp_current_source(solver, n1, n2, comp->value);
                    }
                    break;
                case MNA_CUSTOM_NONLINEAR:
                    mna_stamp_custom_nonlinear(solver, i, 1);
                    break;
                case MNA_SWITCH: {
                    const double g = comp->state ?
                        1.0 / comp->value : MNA_MIN_CONDUCTANCE;
                    mna_stamp_conductance(solver, n1, n2, g);
                    break;
                }
            }
        }

        // Solve linear system to get initial guess
        status = mna_solve_linear_system(solver, matrix_size);
        if (status != MNA_SUCCESS) break;

        // Newton-Raphson iterations at current source level
        int converged = 0;
        int iteration = 0;

        while (!converged && iteration < MNA_MAX_ITER) {
            converged = 1;

            // Update nonlinear component states
            for (int i = 0; i < solver->num_components; i++) {
                Component* comp = &solver->components[i];
                if (comp->type != MNA_CUSTOM_NONLINEAR) continue;

                const int n1 = comp->node1;
                const int n2 = comp->node2;
                const double v1 = (n1 > 0) ? solver->x[n1-1] : 0.0;
                const double v2 = (n2 > 0) ? solver->x[n2-1] : 0.0;
                const double new_voltage = v1 - v2;
                const double voltage_diff = fabs(new_voltage - comp->last_voltage);
                const double abs_tol = MNA_ABSTOL + MNA_RELTOL * fabs(new_voltage);

                // Damping for convergence (0.5 for first 5 iterations, 0.9 after)
                const double damping = (iteration < 5) ? 0.5 : 0.9;
                comp->last_voltage = damping * new_voltage +
                                    (1 - damping) * comp->last_voltage;

                // Update nonlinear parameters
                if (comp->nonlinear_type == NONLINEAR_RESISTOR) {
                    ComponentState state = {
                        .voltage = comp->last_voltage,
                        .current = comp->last_current,
                        .charge = comp->last_charge,
                        .flux = comp->last_flux,
                        .dt = solver->dt
                    };
                    double val1, val2;
                    comp->nonlinear_func(&state, comp->user_data, &val1, &val2);
                    comp->last_conductance =
                        (val2 < MNA_MIN_CONDUCTANCE) ? MNA_MIN_CONDUCTANCE :
                        (val2 > MNA_MAX_CONDUCTANCE) ? MNA_MAX_CONDUCTANCE : val2;
                }

                if (voltage_diff > abs_tol) {
                    converged = 0;
                }
            }

            if (converged) break;

            // Re-stamp nonlinear components with updated values
            mna_reset_system(solver);
            int source_count2 = 0;

            for (int i = 0; i < solver->num_components; i++) {
                Component* comp = &solver->components[i];
                const int n1 = comp->node1;
                const int n2 = comp->node2;

                switch (comp->type) {
                    case MNA_RESISTOR:
                        mna_stamp_conductance(solver, n1, n2, 1.0 / comp->value);
                        break;
                    case MNA_CAPACITOR:
                        mna_stamp_conductance(solver, n1, n2, MNA_MIN_CONDUCTANCE);
                        break;
                    case MNA_INDUCTOR:
                        mna_stamp_conductance(solver, n1, n2, MNA_MAX_CONDUCTANCE);
                        break;
                    case MNA_SOURCE:
                        if (comp->source_type == SOURCE_VOLTAGE) {
                            mna_stamp_voltage_source(solver, i, source_count2++);
                        } else {
                            mna_stamp_current_source(solver, n1, n2, comp->value);
                        }
                        break;
                    case MNA_CUSTOM_NONLINEAR:
                        mna_stamp_custom_nonlinear(solver, i, 1);
                        break;
                    case MNA_SWITCH: {
                        const double g = comp->state ?
                            1.0 / comp->value : MNA_MIN_CONDUCTANCE;
                        mna_stamp_conductance(solver, n1, n2, g);
                        break;
                    }
                }
            }

            status = mna_solve_linear_system(solver, matrix_size);
            if (status != MNA_SUCCESS) break;

            iteration++;
        }

        if (status != MNA_SUCCESS || !converged) {
            // Reduce step size and retry
            step_size /= 2.0;
            if (step_size < min_step) {
                status = MNA_CONVERGENCE_FAILURE;
                break;
            }
            continue;  // Retry with smaller step
        }

        // Successful step - move to next source level
        current_factor = next_factor;
        total_steps++;

        // Increase step size for next step (with upper bound)
        step_size *= 1.5;
        if (step_size > max_step) step_size = max_step;
    }

    // Restore original source values
    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        if (comp->type == MNA_SOURCE) {
            comp->value = orig_source_values[i];
        }
    }
    free(orig_source_values);

    return status;
}

MNAStatus mna_solve_ac(MNASolver* solver, double frequency) {
    double omega = TWO_PI * frequency;
    int matrix_size = mna_active_size(solver);

    if (matrix_size > solver->matrix_cap_size) {
        return MNA_INVALID_PARAMETER;
    }

    // Allocate temporary complex arrays for this solve (could be cached if desired)
    double complex* A_complex = (double complex*)calloc((size_t)matrix_size * (size_t)matrix_size, sizeof(double complex));
    double complex* b_complex = (double complex*)calloc((size_t)matrix_size, sizeof(double complex));
    double complex* x_complex = (double complex*)calloc((size_t)matrix_size, sizeof(double complex));

    if (!A_complex || !b_complex || !x_complex) {
        free(A_complex);
        free(b_complex);
        free(x_complex);
        return MNA_INSUFFICIENT_MEMORY;
    }

    double complex admittance;
    int source_count = 0;

    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        int n1 = comp->node1;
        int n2 = comp->node2;

        switch (comp->type) {
            case MNA_RESISTOR:
                admittance = 1.0 / comp->value;
                if (n1 > 0) A_complex[(n1-1) * matrix_size + (n1-1)] += admittance;
                if (n2 > 0) A_complex[(n2-1) * matrix_size + (n2-1)] += admittance;
                if (n1 > 0 && n2 > 0) {
                    A_complex[(n1-1) * matrix_size + (n2-1)] -= admittance;
                    A_complex[(n2-1) * matrix_size + (n1-1)] -= admittance;
                }
                break;

            case MNA_CAPACITOR:
                admittance = I * omega * comp->value;
                if (n1 > 0) A_complex[(n1-1) * matrix_size + (n1-1)] += admittance;
                if (n2 > 0) A_complex[(n2-1) * matrix_size + (n2-1)] += admittance;
                if (n1 > 0 && n2 > 0) {
                    A_complex[(n1-1) * matrix_size + (n2-1)] -= admittance;
                    A_complex[(n2-1) * matrix_size + (n1-1)] -= admittance;
                }
                break;

            case MNA_INDUCTOR:
                if (omega == 0) {
                    admittance = 1.0 / MNA_MIN_CONDUCTANCE;
                } else {
                    admittance = 1.0 / (I * omega * comp->value);
                }
                if (n1 > 0) A_complex[(n1-1) * matrix_size + (n1-1)] += admittance;
                if (n2 > 0) A_complex[(n2-1) * matrix_size + (n2-1)] += admittance;
                if (n1 > 0 && n2 > 0) {
                    A_complex[(n1-1) * matrix_size + (n2-1)] -= admittance;
                    A_complex[(n2-1) * matrix_size + (n1-1)] -= admittance;
                }
                break;

            case MNA_SOURCE: {
                double complex source_val = comp->ac_magnitude *
                    (cos(comp->ac_phase) + I * sin(comp->ac_phase));

                if (comp->source_type == SOURCE_VOLTAGE) {
                    int v_index = solver->max_node_index + source_count;
                    if (n1 > 0) {
                        A_complex[(n1-1) * matrix_size + v_index] = 1.0;
                        A_complex[v_index * matrix_size + (n1-1)] = 1.0;
                    }
                    if (n2 > 0) {
                        A_complex[(n2-1) * matrix_size + v_index] = -1.0;
                        A_complex[v_index * matrix_size + (n2-1)] = -1.0;
                    }
                    b_complex[v_index] = source_val;
                    source_count++;
                } else {
                    if (n1 > 0) b_complex[(n1-1)] -= source_val;
                    if (n2 > 0) b_complex[(n2-1)] += source_val;
                }
                break;
            }

            case MNA_CUSTOM_NONLINEAR: {
                switch (comp->nonlinear_type) {
                    case NONLINEAR_RESISTOR:
                        admittance = comp->last_conductance;
                        break;
                    case NONLINEAR_CAPACITOR: {
                        ComponentState state = {
                            .voltage = comp->last_voltage,
                            .current = comp->last_current,
                            .charge = comp->last_charge,
                            .flux = comp->last_flux,
                            .dt = solver->dt
                        };
                        double q0, C0;
                        comp->nonlinear_func(&state, comp->user_data, &q0, &C0);
                        admittance = I * omega * C0;
                        break;
                    }
                    case NONLINEAR_INDUCTOR: {
                        ComponentState state = {
                            .voltage = comp->last_voltage,
                            .current = comp->last_current,
                            .charge = comp->last_charge,
                            .flux = comp->last_flux,
                            .dt = solver->dt
                        };
                        double phi0, L0;
                        comp->nonlinear_func(&state, comp->user_data, &phi0, &L0);
                        admittance = 1.0 / (I * omega * L0);
                        break;
                    }
                }

                if (n1 > 0) A_complex[(n1-1) * matrix_size + (n1-1)] += admittance;
                if (n2 > 0) A_complex[(n2-1) * matrix_size + (n2-1)] += admittance;
                if (n1 > 0 && n2 > 0) {
                    A_complex[(n1-1) * matrix_size + (n2-1)] -= admittance;
                    A_complex[(n2-1) * matrix_size + (n1-1)] -= admittance;
                }
                break;
            }

            case MNA_SWITCH: {
                double g = comp->state ?
                    1.0 / comp->value :
                    MNA_MIN_CONDUCTANCE;

                if (n1 > 0) A_complex[(n1-1) * matrix_size + (n1-1)] += g;
                if (n2 > 0) A_complex[(n2-1) * matrix_size + (n2-1)] += g;
                if (n1 > 0 && n2 > 0) {
                    A_complex[(n1-1) * matrix_size + (n2-1)] -= g;
                    A_complex[(n2-1) * matrix_size + (n1-1)] -= g;
                }
                break;
            }
        }
    }

    // Solve complex linear system (Gaussian elim + partial pivoting on magnitudes)
    for (int pivot = 0; pivot < matrix_size; pivot++) {
        int max_row = pivot;
        double max_mag = cabs(A_complex[pivot * matrix_size + pivot]);
        for (int i = pivot + 1; i < matrix_size; i++) {
            double mag = cabs(A_complex[i * matrix_size + pivot]);
            if (mag > max_mag) {
                max_mag = mag;
                max_row = i;
            }
        }

        if (max_mag < MNA_MIN_CONDUCTANCE) {
            free(A_complex);
            free(b_complex);
            free(x_complex);
            return MNA_MATRIX_SINGULAR;
        }

        if (max_row != pivot) {
            for (int j = pivot; j < matrix_size; j++) {
                double complex temp = A_complex[pivot * matrix_size + j];
                A_complex[pivot * matrix_size + j] = A_complex[max_row * matrix_size + j];
                A_complex[max_row * matrix_size + j] = temp;
            }
            double complex tempb = b_complex[pivot];
            b_complex[pivot] = b_complex[max_row];
            b_complex[max_row] = tempb;
        }

        for (int i = pivot + 1; i < matrix_size; i++) {
            double complex factor = A_complex[i * matrix_size + pivot] / A_complex[pivot * matrix_size + pivot];
            if (factor == 0.0) continue;
            for (int j = pivot + 1; j < matrix_size; j++) {
                A_complex[i * matrix_size + j] -= factor * A_complex[pivot * matrix_size + j];
            }
            b_complex[i] -= factor * b_complex[pivot];
            A_complex[i * matrix_size + pivot] = 0.0;
        }
    }

    // Back substitution
    for (int i = matrix_size - 1; i >= 0; i--) {
        x_complex[i] = b_complex[i];
        for (int j = i + 1; j < matrix_size; j++) {
            x_complex[i] -= A_complex[i * matrix_size + j] * x_complex[j];
        }
        x_complex[i] /= A_complex[i * matrix_size + i];
    }

    // Store solution (into capacity-sized buffer's active prefix)
    for (int i = 0; i < matrix_size; i++) {
        solver->ac_solution[i] = x_complex[i];
    }

    free(A_complex);
    free(b_complex);
    free(x_complex);
    return MNA_SUCCESS;
}

void mna_init_transient(MNASolver* solver) {
    solver->time = 0.0;
    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        comp->last_voltage = 0.0;
        comp->last_current = 0.0;
        comp->last_charge = 0.0;
        comp->last_flux = 0.0;
    }
}

MNAStatus mna_solve_transient_step(MNASolver* solver, double dt) {
    solver->dt = dt;
    int matrix_size = mna_active_size(solver);
    mna_reset_system(solver);
    int source_count = 0;

    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        int n1 = comp->node1;
        int n2 = comp->node2;

        switch (comp->type) {
            case MNA_RESISTOR: {
                double g = 1.0 / comp->value;
                mna_stamp_conductance(solver, n1, n2, g);
                break;
            }

            case MNA_CAPACITOR: {
                double G_eq = comp->value / dt;
                double I_eq = -G_eq * comp->last_voltage;
                mna_stamp_conductance(solver, n1, n2, G_eq);
                mna_stamp_current_source(solver, n1, n2, I_eq);
                break;
            }

            case MNA_INDUCTOR: {
                double G_eq = dt / comp->value;
                double I_eq = comp->last_current;
                mna_stamp_conductance(solver, n1, n2, G_eq);
                mna_stamp_current_source(solver, n1, n2, I_eq);
                break;
            }

            case MNA_SOURCE: {
                if (comp->source_type == SOURCE_VOLTAGE) {
                    mna_stamp_voltage_source(solver, i, source_count++);
                } else {
                    mna_stamp_current_source(solver, n1, n2, comp->value);
                }
                break;
            }

            case MNA_CUSTOM_NONLINEAR: {
                mna_stamp_custom_nonlinear(solver, i, 0);
                break;
            }

            case MNA_SWITCH: {
                double g = comp->state ?
                    1.0 / comp->value :
                    MNA_MIN_CONDUCTANCE;
                mna_stamp_conductance(solver, n1, n2, g);
                break;
            }
        }
    }

    MNAStatus status = mna_solve_linear_system(solver, matrix_size);
    if (status != MNA_SUCCESS) {
        return status;
    }

    // Update component states
    for (int i = 0; i < solver->num_components; i++) {
        Component* comp = &solver->components[i];
        int n1 = comp->node1;
        int n2 = comp->node2;

        double v1 = (n1 > 0) ? solver->x[n1-1] : 0.0;
        double v2 = (n2 > 0) ? solver->x[n2-1] : 0.0;
        double v = v1 - v2;

        switch (comp->type) {
            case MNA_CAPACITOR:
                comp->last_current = (v - comp->last_voltage) * (comp->value / dt);
                comp->last_voltage = v;
                break;

            case MNA_INDUCTOR: {
                double di = v * (dt / comp->value);
                comp->last_current += di;
                break;
            }

            case MNA_CUSTOM_NONLINEAR:
                switch (comp->nonlinear_type) {
                    case NONLINEAR_RESISTOR:
                        comp->last_voltage = v;
                        break;

                    case NONLINEAR_CAPACITOR: {
                        ComponentState state = {
                            .voltage = v,
                            .current = comp->last_current,
                            .charge = comp->last_charge,
                            .flux = comp->last_flux,
                            .dt = dt
                        };
                        double q, C;
                        comp->nonlinear_func(&state, comp->user_data, &q, &C);
                        comp->last_voltage = v;
                        comp->last_charge = q;
                        break;
                    }

                    case NONLINEAR_INDUCTOR: {
                        double i_new = comp->trans_I_eq + comp->trans_G_eq * v;
                        ComponentState state = {
                            .voltage = v,
                            .current = i_new,
                            .charge = comp->last_charge,
                            .flux = comp->last_flux,
                            .dt = dt
                        };
                        double phi, L;
                        comp->nonlinear_func(&state, comp->user_data, &phi, &L);
                        comp->last_current = i_new;
                        comp->last_flux = phi;
                        break;
                    }
                }
                break;

            default:
                break;
        }
    }

    solver->time += dt;
    return MNA_SUCCESS;
}

double mna_get_node_voltage(MNASolver* solver, int node) {
    if (node <= 0 || node > solver->max_node_index) return 0.0;
    return solver->x[node-1];
}

double complex mna_get_ac_node_voltage(MNASolver* solver, int node) {
    if (node <= 0 || node > solver->max_node_index) return 0.0;
    return solver->ac_solution[node-1];
}

double mna_get_component_current(MNASolver* solver, ComponentHandle handle) {
    if (handle < 0 || handle >= solver->num_components) return 0.0;

    Component* comp = &solver->components[handle];
    int n1 = comp->node1;
    int n2 = comp->node2;

    double v1 = (n1 > 0) ? mna_get_node_voltage(solver, n1) : 0.0;
    double v2 = (n2 > 0) ? mna_get_node_voltage(solver, n2) : 0.0;
    double v = v1 - v2;

    switch (comp->type) {
        case MNA_RESISTOR:
            return v / comp->value;
        case MNA_CAPACITOR:
            if (!solver->transient_initialized || solver->dt == 0.0) {
                // DC / no transient info â€” capacitor acts as open circuit
                return 0.0;
            } else {
                return (v - comp->last_voltage) * (comp->value / solver->dt);
            }
        case MNA_INDUCTOR:
            return comp->last_current;
        case MNA_SOURCE:
            if (comp->source_type == SOURCE_VOLTAGE) {
                // Find voltage source index
                int vs_index = 0;
                for (int i = 0; i < handle; i++) {
                    if (solver->components[i].type == MNA_SOURCE &&
                        solver->components[i].source_type == SOURCE_VOLTAGE) {
                        vs_index++;
                    }
                }
                return solver->x[solver->max_node_index + vs_index];
            } else {
                return comp->value;
            }
        case MNA_SWITCH:
            return v / (comp->state ? comp->value : 1.0/MNA_MIN_CONDUCTANCE);
        case MNA_CUSTOM_NONLINEAR: {
            ComponentState state = {
                .voltage = v,
                .current = comp->last_current,
                .charge = comp->last_charge,
                .flux = comp->last_flux,
                .dt = solver->dt
            };
            double current, conductance;
            comp->nonlinear_func(&state, comp->user_data, &current, &conductance);
            return current;
        }
        default:
            return 0.0;
    }
}

double mna_get_component_voltage(MNASolver* solver, ComponentHandle handle) {
    if (handle < 0 || handle >= solver->num_components) return 0.0;

    Component* comp = &solver->components[handle];
    int n1 = comp->node1;
    int n2 = comp->node2;

    double v1 = (n1 > 0) ? mna_get_node_voltage(solver, n1) : 0.0;
    double v2 = (n2 > 0) ? mna_get_node_voltage(solver, n2) : 0.0;
    return v1 - v2;
}

#endif // MNA_SOLVER_V2_H
