#include "mna_solver_v2.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int* add_transmission_line(MNASolver* solver, int input_node, int output_node,
                         double R_total, double L_total, double C_total, int segments) {
    if (segments <= 0) return NULL;

    int* line_nodes = (int*)malloc((segments + 1) * sizeof(int));
    if (!line_nodes) return NULL;

    line_nodes[0] = input_node;

    double R_seg = R_total / segments;
    double L_seg = L_total / segments;
    double C_seg = C_total / segments;
    int current_node = input_node;

    for (int i = 0; i < segments; i++) {
        int next_node = (i == segments - 1) ? output_node : mna_create_node(solver);
        int mid_node = mna_create_node(solver);

        mna_add_resistor(solver, current_node, mid_node, R_seg, NULL);
        mna_add_inductor(solver, mid_node, next_node, L_seg, NULL);
        mna_add_capacitor(solver, next_node, 0, C_seg, NULL);

        line_nodes[i + 1] = next_node;

        current_node = next_node;
    }

    return line_nodes;
}

int main() {
    MNASolver solver;
    mna_init_sized(&solver, 4000, 100, 8000);
    double Z0_line1 = 350.0;
    double v_line1 = 3.0e8;
    double L_per_m_line1 = Z0_line1 / v_line1;
    double C_per_m_line1 = 1.0 / (Z0_line1 * v_line1);
    double length_line1 = 100e3;
    double R_total_line1 = 0.01 * length_line1/1000;
    double L_total_line1 = L_per_m_line1 * length_line1;
    double C_total_line1 = C_per_m_line1 * length_line1;
    double Z0_line23 = 75.0;
    double v_line23 = 1.5e8;
    double L_per_m_line23 = Z0_line23 / v_line23;
    double C_per_m_line23 = 1.0 / (Z0_line23 * v_line23);
    double length_line2 = 60e3;
    double R_total_line2 = 0.01 * length_line2/1000;
    double L_total_line2 = L_per_m_line23 * length_line2;
    double C_total_line2 = C_per_m_line23 * length_line2;
    double length_line3 = 30e3;
    double R_total_line3 = 0.01 * length_line3/1000;
    double L_total_line3 = L_per_m_line23 * length_line3;
    double C_total_line3 = C_per_m_line23 * length_line3;

    printf("Параметры линии 1 (60 км):\n");
    printf("  L_total = %.6f мГн\n", L_total_line1*1e3);
    printf("  C_total = %.6f мкФ\n", C_total_line1*1e6);
    printf("Параметры линии 2 (60 км):\n");
    printf("  L_total = %.6f мГн\n", L_total_line2*1e3);
    printf("  C_total = %.6f мкФ\n", C_total_line2*1e6);
    printf("Параметры линии 3 (30 км):\n");
    printf("  L_total = %.6f мГн\n", L_total_line3*1e3);
    printf("  C_total = %.6f мкФ\n", C_total_line3*1e6);

    int source_node = mna_create_node(&solver);
    int line1_end = mna_create_node(&solver);
    int line2_start = mna_create_node(&solver);
    int line2_end = mna_create_node(&solver);
    int inductor_node = mna_create_node(&solver);
    int line3_end = mna_create_node(&solver);

    mna_add_voltage_source(&solver, source_node, 0, 35000.0, NULL);

    ComponentHandle switch_handle;
    mna_add_switch(&solver, line1_end, line2_start, 0.001, &switch_handle);
    mna_set_switch_state(&solver, switch_handle, 0);

    int* line1_nodes = add_transmission_line(&solver, source_node, line1_end,
                                           R_total_line1, L_total_line1, C_total_line1, 400);
    int* line2_nodes = add_transmission_line(&solver, line2_start, line2_end,
                                           R_total_line2, L_total_line2, C_total_line2, 240);
    mna_add_inductor(&solver, line2_end, inductor_node, 0.1, NULL);
    mna_add_resistor(&solver, inductor_node, 0, 100.0, NULL);
    int* line3_nodes = add_transmission_line(&solver, inductor_node, line3_end,
                                           R_total_line3, L_total_line3, C_total_line3, 120);
    mna_add_capacitor(&solver, line3_end, 0, 1e-6, NULL);

    MNAStatus status = mna_solve_dc(&solver);
    if (status != MNA_SUCCESS) {
        printf("Ошибка DC анализа: %d\n", status);
        free(line1_nodes);
        free(line2_nodes);
        free(line3_nodes);
        mna_destroy(&solver);
        return 1;
    }

    solver.transient_initialized = 1;
    solver.time = 0.0;

    for (int i = 0; i < solver.num_components; i++) {
        Component* comp = &solver.components[i];
        int n1 = comp->node1;
        int n2 = comp->node2;
        double v1 = (n1 > 0) ? solver.x[n1-1] : 0.0;
        double v2 = (n2 > 0) ? solver.x[n2-1] : 0.0;
        double voltage = v1 - v2;
        switch (comp->type) {
            case MNA_CAPACITOR:
                comp->last_voltage = voltage;
                comp->last_current = 0.0;
                break;
            case MNA_INDUCTOR:
                if (comp->value > 0) {
                    comp->last_current = 0.0;
                }
                break;
            default:
                break;
        }
    }

    mna_set_switch_state(&solver, switch_handle, 1);

    FILE* csv = fopen("transmission_line_results.csv", "w");
    if (!csv) {
        fprintf(stderr, "Не удалось создать CSV файл\n");
        free(line1_nodes);
        free(line2_nodes);
        free(line3_nodes);
        mna_destroy(&solver);
        return 1;
    }

    fprintf(csv, "time");

    for (int i = 0; i <= 400; i++) {
        double position = (double)i / 400.0;
        fprintf(csv, ",line1_%.3f", position);
    }

    for (int i = 0; i <= 240; i++) {
        double position = (double)i / 240.0;
        fprintf(csv, ",line2_%.3f", position);
    }

    for (int i = 0; i <= 120; i++) {
        double position = (double)i / 120.0;
        fprintf(csv, ",line3_%.3f", position);
    }
    fprintf(csv, "\n");

    fprintf(csv, "0.0");

    for (int i = 0; i <= 400; i++) {
        double voltage = mna_get_node_voltage(&solver, line1_nodes[i]);
        fprintf(csv, ",%.6f", voltage);
    }

    for (int i = 0; i <= 240; i++) {
        double voltage = mna_get_node_voltage(&solver, line2_nodes[i]);
        fprintf(csv, ",%.6f", voltage);
    }

    for (int i = 0; i <= 120; i++) {
        double voltage = mna_get_node_voltage(&solver, line3_nodes[i]);
        fprintf(csv, ",%.6f", voltage);
    }
    fprintf(csv, "\n");

    double t_end = 1e-3;
    double dt = 1e-6;
    int steps = (int)(t_end / dt);
    for (int i = 1; i <= steps; i++) {
        double t = i * dt;
        status = mna_solve_transient_step(&solver, dt);
        if (status != MNA_SUCCESS) {
            printf("Ошибка на шаге %d: %d\n", i, status);
            break;
        }
        fprintf(csv, "%.9f", t);

        for (int i = 0; i <= 400; i++) {
            double voltage = mna_get_node_voltage(&solver, line1_nodes[i]);
            fprintf(csv, ",%.6f", voltage);
        }

        for (int i = 0; i <= 240; i++) {
            double voltage = mna_get_node_voltage(&solver, line2_nodes[i]);
            fprintf(csv, ",%.6f", voltage);
        }

        for (int i = 0; i <= 120; i++) {
            double voltage = mna_get_node_voltage(&solver, line3_nodes[i]);
            fprintf(csv, ",%.6f", voltage);
        }
        fprintf(csv, "\n");

        if (i % (steps/10) == 0) {
            printf("Прогресс: %.0f%% (t=%.6fs)\n", (double)i/steps*100, t);
        }
    }

    fclose(csv);

    free(line1_nodes);
    free(line2_nodes);
    free(line3_nodes);

    mna_destroy(&solver);
    return 0;
}
